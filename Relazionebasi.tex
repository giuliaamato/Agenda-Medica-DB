\documentclass{report}
\usepackage[utf8x]{inputenc}

\begin{document}

\title{\textbf{Progetto di Basi di Dati}}
\author{Giulia Amato, matricola 1075626
\\Paolo Broglio, matricola XXXXXX}
\date{06/2016}
\maketitle
\section*{Abstract}
Il progetto modella la gestione delle visite mediche relative ad un'agenda medica per le principali ASL del territorio Veneto. In particolare, tale agenda potrà essere visualizzata da tre tipi di utenti grazie all'interfaccia web. Essi potranno effettuare delle operazioni tipiche attraverso l'utilizzo di un proprio account:
\begin{enumerate}
\item  Dottori, che hanno la possibilità di creare dei referti e di visualizzarli, visualizzare le visite mediche secondo una tale data e le informazioni dei pazienti
\item Amministratori, che gestiscono la parte amministrativa. Aggiungono nuovi dottori o infermieri, ma possono anche modificarne i dati o eliminarli
\item CUP (Centro Unico Prenotazioni) che ha l'incarico di gestire le prenotazioni attraverso la creazione, modifica e cancellazione.
\end{enumerate}


\section*{Descrizione dei requisiti}
Il progetto in esame vuole analizzare una base di dati che contenga e gestisca le informazioni relative ad un'agenda medica per la gestione delle visite mediche, ed in particolare si vogliono conoscere:
\begin{enumerate}
 \item dati relativi allo svolgimento della visita medica
 \item dati relativi al paziente
 \item dati relativi al dottore
 \item dati relativi all'infermiere
 \item dati relativi alla ASL di appartenenza.
 \end{enumerate} 

 Per ordine, una \textbf{visita medica} è identificata dalle seguenti informazioni:
\begin{itemize}
\item Un codice, che la identifica univocamente
\item Una data
\item Un'ora
\item Una priorità con la quale si potranno eventualmente ordinare le visite
\end{itemize}
Una visita potrà dunque rientrare in due stati (\textit{effettuata} o \textit{prenotata}), ed inoltre una visita potrà essere descritta come \textit{visita di controllo} o come \textit{visita medica}. Al termine di una visita sarà prodotto un \textbf{referto}, dotato di \textit{codice} che lo identifica univocamente e un \textit{testo} che descrive l'avvenuta visita. Ogni visita verrà svolta in un certo \textbf{ambulatorio} contenuto in una data \textbf{ASL} del territorio del Veneto. Una \textbf{ASL} sarà identificata da un \textit{codice} univoco, e avrà altri dati significativi quali \textit{indirizzo} e \textit{contatti} (email e telefono). Inoltre, la gestione delle prenotazioni di visite mediche per ogni \textbf{ASL} verrà effettuata dal \textbf{CUP} (\textit{Centro Unico Prenotazioni}), il quale è identificato da un \textit{codice} univoco e da una \textit{password}, che verranno usati per accedere nella base di dati nell'interfaccia web. Ad ogni \textbf{ASL} afferiscono un certo numero di \textbf{dottori} e \textbf{infermieri}, nonché \textbf{amministratori di sistema}. L'\textbf{amministratore} e il \textbf{dottore} avranno accesso al database per la gestione delle visite, perciò verranno identificati da:
\begin{itemize}
\item Un nome utente, univoco
\item Una password
\item Una data di scadenza della password, che dovrà essere rinnovata 
\item Uno stipendio
\end{itemize}
Per quanto riguarda il \textbf{dottore} è molto importante essere a conoscenza di dati aggiuntivi quali:
\begin{itemize}
\item La specializzazione, affinché le visite di una certa impronta possano essere indirizzate ai dottori competenti su quel settore
\item Orario di inizio e fine turni di lavoro, importante per l'inserimento delle visite in un dato range di tempo
\end{itemize}
Per quanto riguarda l'\textbf{infermiere}, anch'esso avrà come dati significativi lo \textit{stipendio}, ma anche l'attributo \textit{tirocinante}, che identifica la qualifica di un dato infermiere. Tali categorie di utenza avranno tutte una serie di informazioni che caratterizzano un singolo individuo:
\begin{itemize}
\item Un codice fiscale, che identifica univocamente un utente
\item Un nome ed un cognome
\item Una data di nascita
\item Il sesso
\item Contatti quali email e telefono che identificano univocamente un singolo utente
\item Indirizzo, con via e civico
\item Città di nascita e città di residenza
\end{itemize}
Ogni \textbf{città} ha inoltre un \textit{nome univoco}, una \textit{provincia}, un \textit{CAP} e una \textit{regione}, anch'essa con un \textit{nome univoco}. 

\section*{Progettazione concettuale}
\subsection*{Lista delle classi}

\textbf{UTENTE}: rappresenta una persona fisica
\begin{itemize}
\item Nome: string
\item Cognome: string
\item Codice Fiscale: string
\item Data Nascita: date
\item Sesso: bool
\item Email: string
\item Telefono: string
\item Indirizzo (Via, Civico): string
\end{itemize}

Sono definite le seguenti sottoclassi di Utente (con vincolo partizionamento):

1) \textbf{PAZIENTE}: rappresenta i pazienti 
\begin{itemize}
\item Codice Esenzione: string
\end{itemize}

2) \textbf{INFERMIERE:} 
rappresenta gli infermieri di una data ASL
\begin{itemize}
\item Stipendio: string
\item Tirocinante: bool
\end{itemize}

3) \textbf{ACCESSO:} 
rappresentano gli utenti che possono accedere al database
\begin{itemize}
\item Nome utente: string
\item Password: string
\item DataScadenza: date
\end{itemize}

A sua volta, definito in sottoclassi:

1) \textbf{ADMIN:}
Definisce l’admin del sistema

2) \textbf{DOTTORE:}
 Definisce i dottori di una data ASL
\begin{itemize}
\item Specializzazione string
\item Orario Lavoro (Orario Inizio, Orario Fine)
\end{itemize}

3) \textbf{CUP:} 
Ente che gestisce le prenotazioni di una data visita medica
\begin{itemize}
\item Codice: string
\end{itemize}

\textbf{CITTA’:} 
rappresenta le città di una sede o la residenza di un utente
\begin{itemize}
\item Nome: string
\item Provincia: string
\item CAP: string
\end{itemize}

\textbf{REGIONE:} 
rappresenta una regione di appartenenza di una città
\begin{itemize}
\item Nome: string
\end{itemize}

\textbf{ASL:} 
modella le informazioni di una ASL
\begin{itemize}
\item Indirizzo (Via, Civico): string
\item Contatti (Email, Telefono): string
\end{itemize}


\textbf{AMBULATORIO:} 
rappresenta il luogo in cui verrà eseguita una visita medica
\begin{itemize}
\item Nome: string
\end{itemize}

\textbf{VISITA MEDICA:} 
modella le visite mediche 
\begin{itemize}
\item Priorità: string
\item Ora: time
\item Data: date
\item Codice: string
\item Visita / Controllo: bool
\item Prenotata / Effettuata: bool
\end{itemize}

\subsection*{Lista delle associazioni}

\begin{center}
\textbf{UTENTE-CITTA’:}\textit{è nato in}
\end{center}
Ogni utente ha una e una sola città di nascita. Una città può avere 0 o più persone nate in quella città.
Molteplicità 1:N
\begin{center}

\textbf{UTENTE-CITTA’:} \textit{è residente in}
\end{center}
Ogni utente ha una e una sola città di residenza. Una città può avere 0 o più persone residenti in quella città.
Molteplicità 1:N
\begin{center}

\textbf{UTENTE-ASL:} \textit{afferisce in}
\end{center}
***

\begin{center}
\textbf{CITTA’-REGIONE}: \textit{appartiene a}
\end{center}
Ogni Città appartiene ad una e una sola Regione. Una regione può avere una città, o più.
Molteplicità: 1:N
\begin{center}

\textbf{CITTA’-ASL:} \textit{sede di}
\end{center}
 Ogni città può essere sede di zero ASL, o al più una. Una ASL appartiene ad una ed una sola città.
Molteplicità: 1:1
\begin{center}

\textbf{AMBULATORIO-ASL:} \textit{contenuto in}
\end{center}
Ogni ambulatorio è contenuto in  zero ASL, o al più N.  Ogni ASL può avere un ambulatorio, o più.
Molteplicità: N:N

\begin{center}
\textbf{VISITA MEDICA-AMBULATORIO:} \textit{svolta in }
\end{center}
Ogni visita medica si svolge in un ambulatorio, o al più N. In un ambulatorio può essere svolta nessuna visita medica, o più.
Molteplicità N:N

\begin{center}
\textbf{VISITA MEDICA-REFERTO:} \textit{esito di}
\end{center}
Un referto può essere un esito di una e una sola visita medica. Una visita medica può avere zero referti, o al più uno.
Molteplicità 1:1

\begin{center}
\textbf{ASL-CUP:} \textit{gestisce}
\end{center}
Ogni ASL ha le prenotazioni gestite da uno e un solo CUP. Un CUP può gestire una e una sola ASL.
Molteplicità 1:1

\begin{center}
\textbf{INFERMIERE-VISITA MEDICA:} \textit{aiuto}
\end{center}
Ogni infermiere può prendere parte a 0 o N visite mediche. Una visita medica può avere 0 o 1 infermiere che presta servizio.
Molteplicità N:1

\begin{center}
\textbf{PAZIENTE-VISITA MEDICA:} \textit{visitato} 
\end{center}
Ogni paziente può prendere parte di nessuna visita medica, o al più N. Una visita medica invece può avere uno ed un solo paziente.
Molteplicità: 1:N

\begin{center}
\textbf{DOTTORE-VISITA MEDICA}: \textit{tenuta}
\end{center}
Ogni visita medica è tenuta da uno ed un solo dottore, mentre un dottore può tenere 0 o N visite mediche.
Molteplicità: 1:N


\section*{Progettazione logica}
La generalizzazione della classe Utente è stata tradotta tramite sostituzione della generalizzazione con associazioni dato che gli altri due metodi (accorpamento delle figlie della generalizzazione nel genitore, e accorpamento del genitore della generalizzazione nelle figlie) avrebbe appesantito la specificità delle varie entità, provocando diversi svantaggi. Con la sostituzione con associazioni, invece, la generalizzazione si trasforma in associazioni 1 a 1 che legano rispettivamente l'entità genitore con le entità figlie. Non ci sono trasferimenti di attributi.
Viene dunque eliminata la classe Utente. La gerarchia completa viene quindi ridotta alle seguenti classi:


***
\subsection*{Associaizoni}
\begin{center}
\textbf{DATI - CITTA':} \textit{residenza}
\end{center} 
Ogni utente è residente di una sola città, mentre una città può avere da 0 a N residenti. La molteplicità è 1 - N.


\begin{center}
\textbf{DATI - CITTA':} \textit{nascita}
\end{center} 

Ogni utente è nato di una sola città, mentre una città può avere da 0 a N nati nel proprio territorio. La molteplicità è 1 - N.


\begin{center}
\textbf{DATI - ADMIN:} \textit{informazioni}
\end{center} 
Un utente può essere o non essere un admin, mentre un admin è sicuramente un utente. La molteplicità è 1 - 1.


\begin{center}
\textbf{DATI - PAZIENTE:} \textit{informazioni}
\end{center} 
Un utente può essere o non essere un paziente, mentre un paziente è sicuramente un utente. La molteplicità è 1 - 1.


\begin{center}
\textbf{DATI - INFERMIERE:} \textit{informazioni}
\end{center} 
Un utente può essere o non essere un infermiere, mentre un infermiere è sicuramente un utente. La molteplicità è 1 - 1.


\begin{center}
\textbf{DATI - DOTTORE:} \textit{informazioni}
\end{center} 
Un utente può essere o non essere un dottore, mentre un dottore è sicuramente un utente. La molteplicità è 1 - 1.


\begin{center}
\textbf{DATI - ASL:} \textit{afferisce}
\end{center}
Un utente può afferire ad una e una sola ASL, mentre una ASL può avere da 1 a più utenti. La molteplicità è 1 - N. 
****MANCA MOLTEPLICITA SU SCHEMA LOGICO****

\begin{center}
\textbf{CITTA' - ASL:} \textit{sede}
\end{center} 
Un città può essere o non essere sede di una ASL, considerando i piccoli comuni. Mentre una ASL ha sicuramente una sede in una città. La molteplicità è 1 - 1.

\begin{center}
\textbf{ASL - CUP:} \textit{gestione}
\end{center} 
Le prenotazioni per una ASL  vengono gestite da uno e un solo CUP, e un CUP può gestire una e una sola ASL. La molteplicità è 1 - 1.


\begin{center}
\textbf{DOTTORE - VISITA MEDICA:} \textit{organizzazione}
\end{center} 
Un dottore può effettuare una o più visite mediche, mentre una visita medica è sicuramente svolta da un dottore. La molteplicità è N - 1.


\begin{center}
\textbf{VISITA MEDICA - REFERTO:} \textit{esito}
\end{center} 
Un visita medica può produrre o meno un referto , mentre un referto appartiene sicuramente ad un unica visita. La molteplicità è 1 - 1.


\begin{center}
\textbf{PAZIENTE - VISITA MEDICA:} \textit{visitato}
\end{center} 
Un paziente presente nella base dati può essere stato visitato N volte, o può ancora non essere stato visitato. 	Mentre una visita medica riguarda uno ed un solo paziente. La molteplicità è N - 1.


\begin{center}
\textbf{INFERMIERE - VISITA MEDICA:} \textit{aiuto}
\end{center} 
Una visita medica può avere o meno un infermiere che appoggia il dottore, e una infermiere può essere di aiuto in 0 o N visite mediche. La molteplicità è 1 - N.  (****controllare perché nella base dati inserire l'infermiere è obbligatorio****)



\section*{Implementazione della base di dati}
Qui di seguito verrà riportato il codice relativo alla base di dati. Verranno definite le tabelle: 
 \begin{verbatim}
  
CREATE TABLE Informazioni (

	CodiceFiscale  VARCHAR(16) NOT NULL PRIMARY KEY,
	DataNascita    DATE NOT NULL,
	Nome 		   VARCHAR(20) NOT NULL,
	Cognome		   VARCHAR(20) NOT NULL,
	Email		   VARCHAR(45),
	Sesso		   CHAR NOT NULL,
	Telefono	   VARCHAR(20) NOT NULL,
	CittaResidenza VARCHAR(45) NOT NULL,
	CittaNascita   VARCHAR(45) NOT NULL,
	Indirizzo	   VARCHAR(45) NOT NULL,
	CodiceASL 	   INT NOT NULL,

	FOREIGN KEY (CittaResidenza) REFERENCES Citta(Nome) 
		ON UPDATE CASCADE,
	FOREIGN KEY (CittaNascita) REFERENCES Citta(Nome) 
		ON UPDATE CASCADE,
	FOREIGN KEY (CodiceASL) REFERENCES ASL(Codice)) ENGINE=INNODB;

CREATE TABLE Citta (

	Nome 	  VARCHAR(45) NOT NULL PRIMARY KEY,
	Provincia VARCHAR(2) NOT NULL,
	CAP		  VARCHAR(5) NOT NULL,
	Regione   VARCHAR(15) NOT NULL


)ENGINE=INNODB;

CREATE TABLE ASL (
	Codice    INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
	Indirizzo VARCHAR(45) NOT NULL,
	Email     VARCHAR(45) NOT NULL,
	Telefono  VARCHAR(20) NOT NULL,
	CittaSede VARCHAR(45) NOT NULL,
	FOREIGN KEY (CittaSede) REFERENCES Citta(Nome)
		ON UPDATE CASCADE


)ENGINE=INNODB; 


CREATE TABLE CUP (

	Codice VARCHAR(10) NOT NULL PRIMARY KEY,
	Password VARCHAR(10),
	CodiceASL INT NOT NULL,

	FOREIGN KEY (CodiceASL) REFERENCES ASL(Codice) 


) ENGINE=INNODB;


CREATE TABLE DatiAccesso (

	CodiceFiscale VARCHAR(16) NOT NULL PRIMARY KEY,
	NomeUtente VARCHAR(20) NOT NULL UNIQUE,
	Password VARCHAR(20) NOT NULL,
	DataScadenza DATE NOT NULL,
	
	FOREIGN KEY (CodiceFiscale) REFERENCES Informazioni(CodiceFiscale)
		ON DELETE CASCADE

)ENGINE=INNODB;


CREATE TABLE Admin (

	CodiceFiscale VARCHAR(16) NOT NULL PRIMARY KEY,
	NomeUtente VARCHAR(20) NOT NULL,
	Stipendio SMALLINT NOT NULL,

	FOREIGN KEY (CodiceFiscale) REFERENCES Informazioni(CodiceFiscale)
		ON DELETE CASCADE


) ENGINE=INNODB;

CREATE TABLE Dottore (

	CodiceFiscale VARCHAR(16) NOT NULL PRIMARY KEY,
	NomeUtente VARCHAR(20) NOT NULL,
	Stipendio SMALLINT NOT NULL,
	Specializzazione VARCHAR(30) NOT NULL,
	OraInizio TIME NOT NULL,
	OraFine TIME NOT NULL,
	Disponibile BOOL NOT NULL,
	
	FOREIGN KEY (CodiceFiscale) REFERENCES Informazioni(CodiceFiscale)
		ON DELETE CASCADE


) ENGINE=INNODB;

CREATE TABLE Paziente (

	CodiceFiscale VARCHAR(16) NOT NULL PRIMARY KEY,
	CodiceEsenzione VARCHAR(3),

	FOREIGN KEY (CodiceFiscale) REFERENCES Informazioni(CodiceFiscale)
		ON DELETE CASCADE


) ENGINE=INNODB;

CREATE TABLE Infermiere (

	CodiceFiscale VARCHAR(16) NOT NULL PRIMARY KEY,
	Stipendio SMALLINT NOT NULL,
	Tirocinante BOOL NOT NULL,

	FOREIGN KEY (CodiceFiscale) REFERENCES Informazioni(CodiceFiscale)
		ON DELETE CASCADE

)ENGINE=INNODB;


CREATE TABLE VisitaMedica (

	CodiceVisita INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
	Data DATETIME NOT NULL,
	NomeAmbulatorio VARCHAR(5) NOT NULL,
	TipoVisita BOOLEAN NOT NULL,
	TipoPrenotazione BOOLEAN NOT NULL,
	Priorita CHAR,
	CFDottore VARCHAR(16),
	CFInfermiere VARCHAR(16),
	CFPaziente VARCHAR(16) NOT NULL,
	CodiceReferto INT,
	FOREIGN KEY (CFDottore) REFERENCES Dottore(CodiceFiscale)
		ON DELETE SET NULL,
	FOREIGN KEY (NomeAmbulatorio) REFERENCES Ambulatorio(Nome),
	FOREIGN KEY (CFInfermiere) REFERENCES Infermiere(CodiceFiscale)
		ON DELETE SET NULL,
	FOREIGN KEY (CFPaziente) REFERENCES Paziente(CodiceFiscale)
		ON DELETE CASCADE,
	FOREIGN KEY (CodiceReferto) REFERENCES Referto(Codice)
		ON DELETE SET NULL

) ENGINE=INNODB;

CREATE TABLE Referto (

	Codice INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
	Contenuto LONGTEXT NOT NULL


)ENGINE=INNODB;

CREATE TABLE Ambulatorio (

	Nome VARCHAR(5) PRIMARY KEY NOT NULL,
	CodiceASL INT NOT NULL,
	FOREIGN KEY (CodiceASL) REFERENCES ASL(Codice)

)ENGINE=INNODB;
  \end{verbatim}
\section*{Triggers}
1) Questo trigger viene attivato quando un dottore viene eliminato. Nella tabella delle visite mediche tutte quelle prenotate vengono cancellate. Quelle effettuate invece avranno l’attributo CFDottore = NULL poiché il referto deve rimanere disponibile.
\begin{verbatim}
DELIMITER $$
DROP IF EXISTS TRIGGER controlla_visita $$
CREATE TRIGGER controlla_visita
 BEFORE DELETE ON Dottore
 FOR EACH ROW
 BEGIN
     DELETE FROM VisitaMedica 
     WHERE CFDottore=OLD.CodiceFiscale 
     AND TipoPrenotazione=0
 END $$
DELIMITER;
\end{verbatim}

2) Quando una visita medica diventa di tipo "effettuata"(tipoPrenotazione = 1)
 allora controlla il numero di visite a cui a partecipato l'infermiere (se c'è)
 e se questo numero è uguale a 4 allora aumenta di 200 lo stipendio.

\begin{verbatim}
DELIMITER $$
DROP IF EXISTS TRIGGER premio_infermiere $$
CREATE TRIGGER premio_infermiere
BEFORE UPDATE ON VisitaMedica
FOR EACH ROW
BEGIN
    IF conta_visite(OLD.CFInfermiere) = 4
    THEN 
    UPDATE Infermiere
    SET Infermiere.Stipendio = Infermiere.Stipendio+200
    WHERE Infermiere.CodiceFiscale=OLD.CFInfermiere;
    END IF;
END $$
DELIMITER;
\end{verbatim}

\section*{Funzioni}
1) Funzione che permette di calcolare quante visite mediche ha effettuato un certo infermiere.

\begin{verbatim}
CREATE FUNCTION `Conta_Visite`(CF_infermiere VARCHAR(16)) 
RETURNS smallint(5) unsigned
BEGIN
DECLARE tot_visite SMALLINT UNSIGNED;
SELECT Count(*) into tot_visite
FROM VisitaMedica VM
WHERE VM.CFinfermiere = CF_infermiere AND VM.TipoPrenotazione = 1
GROUP BY VM.CFinfermiere;
RETURN tot_visite;
END
\end{verbatim}

2) Funzione che verifica se un dottore con una certa specializzazione è disponibile in una certa ora. La funzione ritorna il codice fiscale di un solo dottore.
\begin{verbatim}
DELIMITER $$
CREATE DEFINER=`root`@`localhost`
FUNCTION `controlla_dottore`(`ora` TIME, `specializzazione` VARCHAR(30)) 
RETURNS varchar(16) CHARSET utf8mb4
NO SQL
BEGIN

DECLARE Disponibilita BOOL;
DECLARE cf VARCHAR(16);
SELECT D.CodiceFiscale,D.Disponibile INTO cf, Disponibilita
FROM Dottore D
WHERE ora BETWEEN D.OraInizio AND D.OraFine
AND D.Specializzazione = specializzazione
LIMIT 1;
IF(Disponibilita=1)
THEN RETURN cf;
ELSE RETURN NULL;
END IF;
END$$
DELIMITER ;
\end{verbatim}


\section*{Query e Procedure}
In questa sezione verranno proposte le query implementate:

1) Query che permette di ottenere il massimo numero di visite mediche effettuate da un infermiere tirocinante,il massimo numero di visite mediche effettuate da un dottore, in cui la priorità delle visite e’ al livello minore (L), e il massimo numero di visite mediche effettuate da un dottore, in cui la priorità delle visite e’ al livello maggiore (H) 
\begin{verbatim}
SELECT MAX(VisiteEffettuate)
FROM (
	SELECT VM.CFinfermiere, VM.CFdottore, COUNT(*) VisiteEffettuate 
	FROM Infermiere i, VisitaMedica VM 
	WHERE i.Tirocinante = 1 AND VM.CFinfermiere = i.CodiceFiscale 
	GROUP BY VM.CFinfermiere, VM.CFdottore ) AS T 
	UNION 
SELECT MAX(VisiteEffettuate) 
FROM (
	SELECT VM.CFdottore, COUNT(*) VisiteEffettuate 
	FROM VisitaMedica VM WHERE VM.TipoPrenotazione = 1 AND VM.Priorita = 'L'
	GROUP BY VM.CFdottore ) AS T2 
	UNION 
SELECT MAX(VisiteEffettuate) 
FROM (
SELECT VM.CFdottore, COUNT(*) VisiteEffettuate 
FROM VisitaMedica VM 
WHERE VM.TipoPrenotazione = 1 AND VM.Priorita = 'H' 
GROUP BY VM.CFdottore ) AS T3
\end{verbatim}


2) Query che, dati i codici fiscali dei dottori che non hanno mai fatto visite mediche, 
mostra il nome utente, il codice fiscale e lo stipendio di questi dottori, 
selezionando coloro che hanno la data scadenza dell’account tra il 1 Gennaio 2016 
e il 1 Ottobre 2016, il cui stipendio e’ maggiore di 3000, il nome utente comprende
una ca\_ , e con l’orario di inizio del turno del lavoro compreso tra le 
9 e le 13, e il turno di fine compreso tra le 13 e le 15.45 

\begin{verbatim}


SELECT D.NomeUtente, D.CodiceFiscale, Doct.Stipendio
FROM DatiAccesso D JOIN Dottore Doct
ON D.CodiceFiscale = Doct.CodiceFiscale 
AND D.DataScadenza BETWEEN "2016-01-01" AND "2016-10-01"
AND Doct.Stipendio>3000 
AND D.NomeUtente LIKE "%ca_%" 
AND Doct.OraInizio BETWEEN "9:00:00" AND "13:30:00"
AND Doct.OraFine BETWEEN "13:00:00" AND "15:45:00" 
AND Doct.CodiceFiscale NOT IN 
(SELECT VM.CFDottore 
FROM VisitaMedica VM, Informazioni I 
WHERE VM.CFdottore=I.CodiceFiscale)

\end{verbatim}


3/ Query che restituisce il codice fiscale dei dottori, il nome, il cognome e, per ogni dottore presente nel base dati, a prescindere dunque delle ASL di appartenenza, conta il numero di visite mediche effettuate nel mese di Luglio 2016 

\begin{verbatim}
SELECT VM.CFdottore, I.Nome, I.Cognome, COUNT(VM.CFdottore) Visite_Effettuate 
FROM VisitaMedica VM JOIN Informazioni I 
ON VM.CFdottore = I.CodiceFiscale 
WHERE VM.CFdottore IN (
SELECT VM.CFdottore 
FROM VisitaMedica VM 
WHERE VM.TipoPrenotazione = 1 
AND VM.Data BETWEEN '2016-05-01 00:00:00' AND '2016-05-31 23:59:59') 
GROUP BY VM.CFdottore
\end{verbatim}

4/ Query che permette di ottenere il codice della ASL che ha il maggior numero di infermieri tirocinanti uomini nati in una data posteriore al 1 Gennaio 1970, e di ottenere il codice della ASL con il maggior numero di infermiere tirocinanti donne, nate anch’esse in una data posteriore a quella già espressa
 \begin{verbatim}
SELECT MAX(T1.CountInf) Num_Tirocinanti  
FROM (
	SELECT COUNT(Infermiere.CodiceFiscale) AS CountInf,Informazioni.CodiceASL 
	FROM Infermiere JOIN Informazioni 
	ON Infermiere.CodiceFiscale=Informazioni.CodiceFiscale 
	WHERE Infermiere.Tirocinante=1 AND 
	CAST(Informazioni.DataNascita as date)>1970-01-01  AND 
	Informazioni.Sesso='M' 
	GROUP BY Informazioni.CodiceASL) T1 
	UNION 
	SELECT MAX(T2.CountInf) Num_Tirocinanti 
	FROM (
	SELECT COUNT(Infermiere.CodiceFiscale) AS CountInf,Informazioni.CodiceASL 
	FROM Infermiere JOIN Informazioni 
	ON Infermiere.CodiceFiscale=Informazioni.CodiceFiscale 
	WHERE Infermiere.Tirocinante=1 AND 
	CAST(Informazioni.DataNascita as date)>1970-01-01 
	AND Informazioni.Sesso='F' 
	GROUP BY Informazioni.CodiceASL) T2
\end{verbatim}

5/ Query che restituisce nome, cognome, codice dell’ASL di appartenenza e numero di visite effettuate dei dottori che nel mese precedente hanno effettuato meno di 5 visite mediche
\begin{verbatim}
SELECT DISTINCT Informazioni.Nome, Informazioni.Cognome, Informazioni.CodiceASL,
Informazioni.CodiceFiscale, COUNT(*) NumeroVisite 
FROM VisitaMedica JOIN Informazioni 
ON Informazioni.CodiceFiscale = VisitaMedica.CFDottore 
WHERE TipoPrenotazione=1 AND 
EXTRACT(YEAR FROM VisitaMedica.Data)=
EXTRACT(YEAR FROM DATE_SUB(CURDATE(),INTERVAL 1 MONTH)) 
AND EXTRACT(MONTH FROM VisitaMedica.Data)=
EXTRACT(MONTH FROM DATE_SUB(CURDATE(),INTERVAL 1 MONTH)) 
GROUP BY CFDottore 
HAVING COUNT(*)<5
\end{verbatim}

6/ Query che rende possibile ordinare le visite mediche ancora da effettuare per anzianità, mostrando il nome e il cognome del paziente, ma anche la data di nascita e il codice fiscale. Avremo a disposizione anche le informazioni relative alla visita medica prenotata, mostrano il nome dell’ambulatorio in cui verra’ eseguita la visita, il tipo di visita, i codici fiscali dei dottori e degli infermieri 
\begin{verbatim}


SELECT I.Nome, I.Cognome, I.DataNascita, VM.CFPaziente, I.CodiceASL,
VM.CodiceVisita, VM.Data, VM.NomeAmbulatorio, VM.TipoVisita,
VM.Priorita, VM.CFDottore, VM.CFInfermiere, VM.CodiceReferto 
FROM VisitaMedica VM  JOIN Informazioni I 
WHERE VM.CFpaziente = I.CodiceFiscale 
AND VM.TipoPrenotazione = 0 
ORDER BY I.DataNascita
\end{verbatim}


7/ Procedura che permette di effettuare un ordinamento per data (crescente o decrescente) delle visite mediche prenotate ancora da effettuare 
\begin{verbatim}

CREATE PROCEDURE `Ordina_Data`(IN Ordinamento BOOLEAN)
BEGIN
SELECT *
FROM VisitaMedica
WHERE VisitaMedica.TipoPrenotazione=0
ORDER BY
CASE WHEN Ordinamento = 0 THEN Data END,
CASE WHEN Ordinamento = 1 THEN Data END DESC;
END
\end{verbatim}

8/Procedura che permette di effettuare un ordinamento per priorità (H o L) delle visite mediche prenotate ancora da effettuare
\begin{verbatim}
CREATE PROCEDURE `Ordina_Priorita`(IN Prio CHAR(1))
BEGIN
SELECT *
FROM VisitaMedica
ORDER BY
CASE WHEN Prio = 'L' THEN Priorita END DESC,
CASE WHEN Prio = 'H' THEN Priorita END,
CASE WHEN Prio NOT IN ('L', 'H') THEN Priorita END DESC
\end{verbatim}

9/PROCEDURA CHE RESTITUISCE GLI AMBULATORI DISPONBILI IN UNA CERTA DATA E DI UNA CERTA ASL
\begin{verbatim}
#
# VIEW NECESSARIA
# 
CREATE VIEW ambulatori_prenotati AS 
SELECT Ambulatorio.Nome, VisitaMedica.Data 
FROM Ambulatorio 
JOIN VisitaMedica 
ON Ambulatorio.Nome=VisitaMedica.NomeAmbulatorio 
WHERE VisitaMedica.TipoPrenotazione = 0;


#
# PROCEDURA CHE RESTITUISCE GLI AMBULATORI DISPONBILI IN UNA CERTA DATA E 
# DI UNA CERTA ASL
# 
DELIMITER $$
CREATE PROCEDURE ambulatori_disp(IN data_scelta DATE, 
IN ora_scelta TIME, IN cf_dottore VARCHAR(16))
BEGIN
DECLARE conta INTEGER;
CREATE TEMPORARY TABLE temp (nome VARCHAR(5));
INSERT INTO temp
SELECT ambulatori_prenotati.Nome
FROM ambulatori_prenotati 
JOIN Ambulatorio 
ON ambulatori_prenotati.Nome = Ambulatorio.Nome  
WHERE DATE_FORMAT(ambulatori_prenotati.Data,'%Y-%m-%d') = data_scelta
AND Ambulatorio.CodiceASL = 
(SELECT CodiceASL FROM Informazioni W
HERE Informazioni.CodiceFiscale=cf_dottore)
AND DATE_FORMAT(ambulatori_prenotati.Data, "%T") 
BETWEEN OraInizio(cf_dottore)
AND OraFine(cf_dottore)
AND DATEDIFF(OraFine(cf_dottore),
DATE_FORMAT(ambulatori_prenotati.Data,"%T")) > '00:30:00'
AND 
(DATEDIFF(DATE_FORMAT(ambulatori_prenotati.Data,"%T"),ora_scelta) > '00:30:00'
OR 
DATEDIFF(ora_scelta,DATE_FORMAT(ambulatori_prenotati.Data,"%T")) > '00:30:00');

SELECT COUNT(*) INTO conta FROM temp;

IF conta > 0 
THEN SELECT * FROM temp;
ELSE 
SELECT Ambulatorio.Nome 
FROM Ambulatorio WHERE Ambulatorio.CodiceASL=
(SELECT CodiceASL FROM Informazioni WHERE Informazioni.CodiceFiscale=cf_dottore) 
AND Ambulatorio.Nome 
NOT IN (SELECT VisitaMedica.NomeAmbulatorio 
FROM VisitaMedica WHERE VisitaMedica.TipoPrenotazione=0);
END IF;

END $$
DELIMITER;

\end{verbatim}



\section*{Interfaccia Web}
\end{document}
